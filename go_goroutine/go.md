# 고루틴

0. 고루틴은 Go언어에서 관리하는 경량 스레드.<br>
   여러 고루틴을 갖는 프로그램을 코딩하는 것을 동시성 프로그래밍이라고 한다.<br>

1. 고루틴은 경량 스레드로 함수나 명령을 동시에 실행 할 때 사용한다. <br>
   프로그램 시작점인 main()함수 역시 고루틴에 의해서 실행된다.<br>

2. “lightweight thread managed by the Go runtime”  <br>
   Go 런타임에서 관리되는 경량 스레드.  <br>
    <br>
   여기에서 말하는 경량스레드는 OS 레벨의 쓰레드와는 다른 개념이며, Go 언어 런타임에서 관리되는 논리적 (혹은 가상적)쓰레드라고 한다.  <br>


스레드

0. 스레드는 실행 흐름
   과거 천공카드 다발을 스레드로 볼 수 있다.<br>
   이 명령어가 적힌 종이 다발을 CPU가 한 줄씩 읽어서 수행하는 것이 컴퓨터, <br>
   CPU코어는 한 번에 하나의 명령어 다발(스레드)를 수행 할 수 있다.<br>

컨텍스트 스위칭

0. CPU 코어가 여러 스레드를 전환하면서 수행하면 더 많은 비용이 든다.<br>

1. 스레드를 전환하려면 현재 상태를 보관해야 한다.<br>
   이때 스레드의 명령 포인터, 스택 메모리 드으이 정보를 저장하게 되는데 이를 스레드 컨텍스트라고 한다.<br>

2. 스레드가 전활 될 때마다 스레드 컨텍스트를 저장하고 복원하기 때문에, 스레드 비용이 들게 되는 것이며,<br>
   적정 개수를 넘어 한 번에 너무 많은 스레드를 수행하면 성능이 저하된다.<br>

3. 일반적으로 코어 개수의 두 배 이상 스레드를 만들면 스위칭 비용이 많이 발생한다고 한다.<br>

<br>

### 고루틴, 쓰레드 차이

<br>

고루틴과 쓰레드의 차이점. <br>

1. 메모리 소비 <br>

   Go에서 고루틴을 생성할 때 많은 메모리를 필요로 하지 않는다. <br>
   고루틴 생성 시 , 약 2KB의 스택 메모리 공간만 필요하며, 필요에 따라 힙 메모리 공간을 사용하기도 한다. <br>

   반면 쓰레드는 쓰레드가 사용할 메모리 공간과 각 메모리 간의 경계 역할을 하는 Guard Page라고 불리는 메모리 영역과 함께 포함하여 1Mb의 메모리 공간을 소모하여 생성된다.<br>

   따라서 Golang 기반의 서버에서는 요청 1건 당 1개의 고루틴을 생성 하도록 만들 수 있지만, <br>
   요청 1건 당 1개의 쓰레드를 할당하는 다른 언어 기반의 서버는 앞선 방식으로 쓰이게 되면 결국에는 OOM(OutOfMemory) 이슈의 원인이 될 것이다. <br>

   이는 쓰레드를 사용하는 언어기반으로 만들어진 서버가 지속적으로 스레드 생성 요청을 받게 된다면 마주하게될 이슈이다. <br>
   
2. 생성, 소거 비용 <br>

   OS 스레드는 생성/소거 시 많은 비용이 들어가게 된다. <br>
   OS로 부터 쓰레드 리소스를 , 요청을 통해 생성하고, 쓰레드 작업 완료 시 해당 리소스를 OS에 다시 반환 해야 하기 때문이다. <br>

   GO의 고루틴은 런타임에서 논리적 (OS 레벨 스레드와 달리 하드웨어에 의존적이지 않는다.) 으로 생성되고 소거되기 때문에 상대적으로 해당 작업들에 소모되는 비용이 저렴하다. <br>
   따라서 Go 언어에서는 이러한 고루틴을 수동 관리하는 메뉴얼을 제공하지 않는다. <br>
   고루틴은 OS 쓰레드와 상대적으로 앞선 OOM과 같은 문제에 대한 걱적이나 부담없이 생성하여 사용해도 된다고 표현하곤 한다. <br>

3. Context Switching 비용 <br>

   하나의 스레드가 특정 작업을 처리하기 위해서 Blocking 된다면 다른 스레드가 그 대신하여 처리하도록 스케줄링이 되어 있다. <br>
   쓰레드가 스케줄링이되고 스레드가 교체되는 동안에 스케줄러에서는 모든 레지스터들을 Save/restore 해야 한다. <br>

   일반적인 스레드 Context Switching 작업 시 16개의 범용 레지스터, PC(Program Counter), SP(Stack Pointer), Sement 레지스터, 16개의 XMM레지스터, <br>
   FP coprocessor state, 16개의 AVX 레지스터, 모든 MSR들 등 Save,Restore 작업을 진행해야 한다. <br>

   따라서 이와 같은 작업을 처리하기 때문에, 생각보다 Context Switching 시 많은 비용을 소모하게 된다고 말하는 것이다. <br>

   #### 하지만 고루틴은 3개의 레지스터 (PC/SP/DX)만 save/restore 작업을 하기 때문에 상대적으로 스레드보다 Context Switching 비용을 적게 소모한다. <br>

<br>

OS 쓰레드와 달리 고루틴은 Go 언어 자체적으로 구현화된 쓰레드라고 볼 수 있으며, <br>
OS 쓰레드에 비해서 상대적으로 메모리 비용이 적게 소모되기 때문에 경량 쓰레드라고 불린다.<br>

<br>


## 고루틴은 어떻게 실행되는가. 

<br>

Go 언어는 프로그램 시작과 끝나는 시점까지 런타임 내내 고루틴들을 관리한다. <br>
또한 고루틴은 M:N 쓰레드 모델(LWP)을 채택하고 있어서 기존의 쓰레드/쓰레드 Pool를 활용하는 방식보다 더 가볍고 빠른 특성을 지니고 있다. <br>

<br>

### 쓰레드 타입별 특징

<br>

1. User-Level 쓰레드

   사용자 라이브러리를 통해 쓰레드 관리 기능이 제공되고, 
   여러 User_level 스레드가 1개의 OS 쓰레드 위에서 동작하는 형태 (1:N)

   - Context Switching 비용이 적기 때문에 속도가 빠르다.
   - OS 스레드 1개만 사용하는 구조이기 때문에 멀티 코어를 활용할 수 없다.
   - User_level 중 하나가 syscall으로 인해 Block 되면 나머지 User_Level 스레드들도 멈추게 된다.
     이는 Kernel이 프로세스 내부의 쓰레드를 인식하지 못하여 해당 프로세스를 대기 상태로 전환시키기 때문이다.

<br>

2. Kernel-Level 쓰레드

   Kernel_Level 쓰레드는 운영체제가 지원하는 기능으로 구현되어 , 즉 kernel이 쓰레드의 생성, 스케줄링을 담당하게 된다.
   1개의 OS 스레드에 1개의 User_level 쓰레드를 할당 (1:1)

   - kernel은 프로세스 내의 다른 쓰레드를 중단시키지 않고 계속 실행.
   - 멀티 프로세싱 환경에서는 커널은 여러개의 스레드를 각각 다른 프로세서에 할당할 수 있다.
   - 멀티 코어를 제대로 활용할 수 있다.
   - Context Switching 비용이 비싸 속도가 느리다.

<br>

3. Combined 

   Kernel-level 쓰레드와 User-level 스레드를 혼합하여 사용하는 방식.
   위 두 방식의 장점을 혼합한 방식이라고 할 수 있다. (M:N)

   - User-level 스레드는 LWP에 의해 다중화(Multiplexing) 된다.
   - LWP는 Kernel과 프로세스 사이에서 중간자 역할
   - Context Switching 속도가 빠르고 멀티 코어 활용도 가능하다.
   - 구현 어렵.


## GO 언어는 Combined(M:N)모델을 활용하고 있다.

<br>

고루틴 (User_Level 스레드) - OS 스레드 (kernel-_level 스레드)를 M:N 매핑하는 형태도 스케줄링 된다.
Context Switching, 멀티 코어에 대한 장점을 누리고 있고, 구현하기 어렵다는 단점을 언어적 차원에서 해당 단점을 해소 시키고 있다.

https://kspsd.tistory.com/50

<br>
고루틴

<br>
고루틴을 추가로 생성하는 구문

<br>

```go
go 함수_호출
```
<br>
go 키워드를 쓰고, 함수를 호출하면 해당 함수를 수행하는 새로운 고루틴을 생성한다. 

<br>

예시 : 링크

<br>

### 메인 함수가 종료되면 아무리 많은 고루틴이 생성되어 있더라도, 모두 즉시 종료되고 프로그램이 종료된다.

<br>

함수의 대기 시간을 항상 아는 것은 굉장히 어려운 일이다. <br>
이러한 문제를 해결하기 위해서 아래의 방법을 활용할 수 있다. <br>

```go
var wg sync.WaitGroup

wg.Add(3) // 작업 개수 설정
wg.Done() // 작업이 완료 될때 마다 호출
wg.Wait() // 모든 작업이 완료될 때 까지 대기

```
<br>

### sync.WaitGroup으로 고루틴의 개수를 정하고 호출할 수 있는데,
### 만약 여기에서 sync.WaitGroup의 개수보다 실제 고루틴의 개수가 적다면 DeadLock이 발생한다.
<br>

```terminal

fatal error: all goroutines are asleep - deadlock!

goroutine 1 [semacquire]:
sync.runtime_Semacquire(0x4a30d0?)
        /usr/local/go/src/runtime/sema.go:62 +0x27
sync.(*WaitGroup).Wait(0x0?)
        /usr/local/go/src/sync/waitgroup.go:116 +0x4b
test/go_study.TestGo2()
        /home/swchoi/Desktop/test/go_study/go_2.go:33 +0x54
main.main()
        /home/swchoi/Desktop/test/main.go:20 +0x17

```

### sync.WaitGroup으로 고루틴의 개수보다 많은 go루틴을 정의해서 정해진 개수만큼만 실행된다.



